# -*- coding: utf-8 -*-
"""Compare analytics reports and generate cross-market insights.

This script loads detailed JSON summary reports generated by the analytics
pipeline for multiple markets. It processes this data to calculate key
comparative metrics, prints a summary table, and generates qualitative
insights based on the findings.
"""
import json
import pandas as pd
from pathlib import Path
import numpy as np
from typing import Optional # <--- FIX 1: ADD THIS IMPORT

# --- Configuration ---
# Assume the script is run from the project's root directory.
REPORTS_DIR = Path(__file__).parent / "outputs" / "reports"
MARKETS = ["vero", "zito", "tinex", "stokomak"]


def load_and_process_report(market_name: str) -> Optional[dict]: # <--- FIX 2: CHANGE THE RETURN TYPE HINT
    """Loads and processes the detailed analytics report for a single market.

    This function reads a market's JSON report file. It then calculates
    summary statistics that may not be directly present in the raw report,
    such as the overall average price across all categories.

    Args:
        market_name (str): The name of the market (e.g., 'vero', 'stokomak').

    Returns:
        A dictionary containing key summary statistics for comparison,
        or None if the report file for the specified market is not found.
    """
    report_path = REPORTS_DIR / f"{market_name}_summary_analytics_report.json"
    if not report_path.exists():
        print(f"‚ö†Ô∏è  Warning: Report for '{market_name}' not found at {report_path}")
        return None

    with open(report_path, 'r', encoding='utf-8') as f:
        report_data = json.load(f)

    # --- Calculate metrics "on-the-fly" from the detailed report ---

    # Calculate the overall average price from the per-category averages.
    avg_price = None
    if report_data.get('average_price_per_category'):
        # Using np.mean is robust as it handles empty lists gracefully.
        prices = list(report_data['average_price_per_category'].values())
        if prices:
            avg_price = np.mean(prices)

    # Find the most expensive category and its average price.
    most_expensive_category = None
    highest_category_price = None
    if report_data.get('average_price_per_category'):
        avg_prices_by_cat = report_data['average_price_per_category']
        if avg_prices_by_cat:
            most_expensive_category = max(avg_prices_by_cat, key=avg_prices_by_cat.get)
            highest_category_price = avg_prices_by_cat[most_expensive_category]

    # Count the number of unique product categories.
    num_categories = 0
    if report_data.get('products_per_category'):
        num_categories = len(report_data['products_per_category'])

    # Consolidate the key data points into a clean dictionary.
    summary_data = {
        'market': market_name,
        'total_products': report_data.get('total_products'),
        'num_categories': num_categories,
        'products_on_discount': report_data.get('products_on_discount', 0),
        'average_price': avg_price,
        'most_expensive_category': most_expensive_category,
        'highest_category_price': highest_category_price,
    }
    return summary_data


def generate_insights(df: pd.DataFrame) -> str:
    """Generates a formatted string of insights based on the combined report data.

    Args:
        df (pd.DataFrame): DataFrame containing the combined, processed data.

    Returns:
        str: A multi-line string containing the formatted insights report.
    """
    report_parts = []
    report_parts.append("\n" + "=" * 80)
    report_parts.append("üõí                        MARKET INSIGHTS REPORT")
    report_parts.append("=" * 80)

    # --- Insight 1: Assortment Size and Variety ---
    report_parts.append("\n--- 1. Assortment and Variety ---")
    most_products_market = df.loc[df['total_products'].idxmax()]
    most_categories_market = df.loc[df['num_categories'].idxmax()]
    report_parts.append(f"üèÜ Largest assortment: '{most_products_market.name}' with {most_products_market['total_products']} products.")
    report_parts.append(f"üìö Greatest variety: '{most_categories_market.name}' with {most_categories_market['num_categories']} unique categories.")

    # --- Insight 2: Pricing Strategy ---
    report_parts.append("\n--- 2. Pricing Strategy ---")
    highest_avg_price_market = df.loc[df['average_price'].idxmax()]
    lowest_avg_price_market = df.loc[df['average_price'].idxmin()]
    report_parts.append(f"üí∞ Highest average price: '{highest_avg_price_market.name}' with an average of {highest_avg_price_market['average_price']:.2f} MKD.")
    report_parts.append(f"üè∑Ô∏è Lowest average price: '{lowest_avg_price_market.name}' with an average of {lowest_avg_price_market['average_price']:.2f} MKD.")

    # --- Insight 3: Premium Categories ---
    report_parts.append("\n--- 3. Premium Category Focus ---")
    report_parts.append("Markets ranked by the average price of their most expensive category:")
    premium_focus_markets = df.sort_values(by='highest_category_price', ascending=False)
    for market_name, row in premium_focus_markets.iterrows():
        report_parts.append(f"  - '{market_name}': Top category is '{row['most_expensive_category']}' with an avg. price of {row['highest_category_price']:.2f} MKD.")

    # --- Insight 4: Discount Analysis (if data is available) ---
    if 'products_on_discount' in df.columns and df['products_on_discount'].sum() > 0:
        report_parts.append("\n--- 4. Discount Analysis ---")
        most_discounted_market = df.loc[df['products_on_discount'].idxmax()]
        report_parts.append(f"üéÅ Most items on discount: '{most_discounted_market.name}' with {int(most_discounted_market['products_on_discount'])} items.")
    else:
        report_parts.append("\n--- 4. Discount Analysis ---")
        report_parts.append("  (No products on discount found in the loaded reports)")

    report_parts.append("\n" + "=" * 80)
    return "\n".join(report_parts)


def main():
    """Main function to orchestrate the loading, comparison, and reporting.

    This function iterates through the configured markets, loads and processes
    their respective reports, aggregates the data into a single pandas DataFrame,
    prints a summary table, and then calls the function to generate qualitative insights.
    """
    all_reports_data = []
    for market in MARKETS:
        # Use the new processing function.
        summary_data = load_and_process_report(market)
        if summary_data:
            all_reports_data.append(summary_data)

    if not all_reports_data:
        print("‚ùå Error: No analytics reports found. Please run the pipeline first.")
        return

    # Create a DataFrame for easy comparison and analysis.
    df = pd.DataFrame(all_reports_data)
    df = df.set_index('market')  # Use market name as the index for clarity.

    # Define the columns to display in the main summary table.
    display_cols = ['total_products', 'num_categories', 'average_price', 'products_on_discount']
    # Filter for columns that actually exist in the DataFrame to avoid errors.
    final_display_cols = [col for col in display_cols if col in df.columns]

    # --- Build the full report as a string ---
    report_parts = []
    report_parts.append("=" * 80)
    report_parts.append("üìä                  ACROSS-MARKET COMPARISON")
    report_parts.append("=" * 80)
    report_parts.append(df[final_display_cols].round(2).to_string())

    # --- Generate and add insights ---
    insights_df = df.dropna(subset=['total_products', 'average_price', 'num_categories'])
    if not insights_df.empty:
        insights_string = generate_insights(insights_df)
        report_parts.append(insights_string)
    else:
        insights_string = "\n‚ö†Ô∏è  Could not generate insights due to missing data in reports."
        report_parts.append(insights_string)

    full_report = "\n".join(report_parts)
    
    # --- Print to console ---
    print(full_report)

    # --- Save to file ---
    output_dir = Path(__file__).parent / "outputs"
    output_dir.mkdir(exist_ok=True)
    output_file_path = output_dir / "market_comparison_report.txt"
    try:
        with open(output_file_path, 'w', encoding='utf-8') as f:
            f.write(full_report)
        print(f"\n‚úÖ Report saved successfully to: {output_file_path}")
    except IOError as e:
        print(f"\n‚ùå Error saving report to file: {e}")


if __name__ == "__main__":
    main()